# 类型参数提案

Ian Lance Taylor
Robert Griesemer
2021 年 8 月 20 日

### 状态

这是一个使用类型参数为 Go 语言添加泛型的设计。此提案已经被接受至未来的语言变动内，并预计将在2022年初的GO 1.18版本中提供。

### 摘要

我们建议扩展 Go 语言，为类型和函数声明添加可选的类型参数。类型参数受接口类型的约束。当接口类型被用作类型约束时，可以嵌入其他元素，这些元素可用于限制哪些类型是满足约束的。在满足所有符合参数约束的类型的限制条件时，参数化类型和函数可以将运算符与类型参数一起使用。通过统一算法的类型推理，函数调用在许多情况下得以省略类型参数。该设计与 Go 1完全向后兼容。

### 如何阅读此提案

这份文档有些长。以下是一些阅读指南：

- 首先，我们从一个高维度简单概述了相关概念。
- 之后，我们从零开始解释了整个设计，并在必要时用简单的示例介绍了一些细节。
- 在完成对设计的描述之后，我们将讨论实现、设计中的一些问题，并与其他泛型实现进行了比较。
- 然后，我们通过几个完整的示例，说明此设计将如何在实践中使用。
- 在示例之后，附录中讨论了一些次要的细节。

### 高维度概述

此部分简要地解释了这份设计提议了哪些更改，并主要面向已经熟悉泛型如何在类似 Go 的语言中工作的人。以下概念将在后文的各小节中详细说明。

- 函数可以额外添加一个类型参数列表，该列表使用方括号（而不是圆括号），其他方面看起来与普通参数列表类似： `func F[T any](p T) { ... }`。
- 这些类型参数可以由常规参数使用，也可以在函数体内使用。

- 类型还可以有类型参数列表：`type M[T any] []T`。
- 每个类型参数都有一个类型约束，就像每个普通参数都有类型一样：`func F[T Constraint](p T) { ... }`。
- 类型约束是一种接口。
- 新的预声明名称 `any` 是一个允许任何类型的类型约束。
- 用作类型约束的接口可以嵌入附加元素，以限制有哪些类型参数是满足约束的：
  - 任意类型 `T` 限制为该类型
  - 近似元素 `~T` 限制到所有基础类型为 `T` 的类型
  - 联合元素 `t1|t2|...` 限制为列出的元素之一
- 泛型函数只能使用所有约束中所允许的类型都支持的操作。
- 使用泛型函数或类型时，需要传递类型参数。
- 类型推断使得在常规情况下，函数调用的类型参数可以被省略。

在下文，我们将详细介绍这些语言更改。也许您会更倾向于先跳到更靠后的示例部分，看看在实践中使用此设计编写的泛型代码是什么样子。

### 背景

已经有很多人请求在 Go 中添加对泛型编程的额外支持。在 issue追踪器 和 living document 上都已经有了不少关于此事的广泛讨论。
我们设计了一种参数多态，其中类型参数不像某些面向对象的语言一样由声明的子类型关系限定，而是由显式定义的结构约束限定的。这份提案建议 Go语言采用这种设计作为拓展，以实现泛型。
这个版本的设计与2019年7月31日提交的设计草案有许多相似之处，但这份提案中使用的contract已被删除，并被接口类型取代，语法也发生了变化。
上面的链接中有几个添加类型参数的提案，这里提出的许多设想在以前的讨论中都有迹可循。这里主要描述的新特性在于语法和约束的接口类型上的细致的类型检查。
此设计不支持模板元编程或任何其他形式的编译时编程。
由于「泛型」这个术语在 Go 社区中被广泛使用，我们将在下面使用它作为一种简写，代指接受类型参数的函数或类型。不要将本设计中使用的术语泛型与其他语言（如C++、C#、Java或Rust）中的相同术语混淆；它们有相似之处，但并不相同。

### 设计

我们将用一些简单的例子分段描述整个设计。

##### 类型参数

泛型代码是使用抽象数据类型编写的，我们将这种抽象数据类型称为类型参数。运行泛型代码时，类型参数将替换为类型声明。
下面是一个函数，功能是打印切片的每个元素。其中切片的元素类型是未知的，这里称为T。这是我们为了支持泛型编程而设计的函数类型的一个小例子。(稍后我们还将讨论泛型类型)。

```go
// Print 打印切片中的元素。
// 它应该可以被任何切片类型的值调用。
func Print(s []T) { // 只是示例，并不建议这种语法。
	for _, v := range s {
		fmt.Println(v)
	}
}
```

使用这种方法时，首先应当决定的是：应该如何声明类型参数T？在像 GO 这样的语言中，我们希望每个标识符都应该以某种方式被声明。
这里我们做了一个设计决策：类型参数与普通的（非类型函数的）参数类似，因此应该与其他参数一起列出。但是，类型参数与非类型参数又是不同的，因此尽管它们出现在参数列表中，但我们希望将它们区分开。这引出了我们的下一个设计决策：我们定义了一个附加的可选参数列表，用于描述类型参数。

这种类型参数列表表示在常规参数之前。为了区分类型参数列表和常规参数列表，我们在类型参数列表上使用方括号而不是圆括号。正如常规参数具有类型一样，类型参数也具有元类型，也称为约束。我们将在稍后讨论约束的细节；现在，我们只需要知道 `any` 是一种有效的约束，代表其允许任意类型。

```go
// Print 可以打印任何切片中的元素。
// Print 具有参数类型 T， 并且只有一个（普通）参数s，该参数是 T 类型参数的切片。
func Print[T any](s []T) {
	// 同上文
}
```

这表明在函数 Print 中，标识符 T 是一个类型参数，这个类型当前是未知的，但是在调用该函数时会知道。Any 意味着 T 可以是任何类型。如上所示，在描述普通参数(非类型参数)的类型时，可以将类型参数用作类型。它也可以在函数体内作为一种类型使用。

与常规参数列表不同，在类型参数列表中，类型参数必须提供名称。这样不仅可以避免语法上的歧义，同时也没有理由省略类型参数的名称。
因为 Print 声明了类型参数，所以任何对 Print 的调用都必须提供一个类型参数。稍后我们将看到如何通过使用类型推断从非类型参数推导出这个类型参数。现在，我们将显式地传递类型参数。传递类型参数和声明类型参数非常像: 使用一个单独的参数列表传递即可。与类型参数列表的风格一致，声明类型参数列表时使用方括号。

```go
	// 用 []int（类型的数据）调用 Print.
	// Print 具有参数类型 T，并且我们想向其传递 []int
	// 所以我们通过Print[int]的格式来向其传递 int 的类型参数。
	// Print[int] 这个函数需要一个 []int 作为其参数。
	Print[int]([]int{1, 2, 3})

	// 这个函数会打印如下几行:
	// 1
	// 2
	// 3
```

##### 约束

我们来把这个例子改得稍微复杂一点。我们把这个函数改为通过调用每个元素上的 `String` 方法将任意类型的切片转换为`[]string`。

```go
// 此函数是*无效*的
func Stringify[T any](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String()) // *无效*
	}
	return ret
}
```

乍一看似乎没问题，但是这里 v 的类型是 T，T 可以是任何类型。这意味着 T 不需要一个 String 方法。因此，对 v. String ()的调用是无效的。

当然，同样的问题也会出现在其他支持泛型的语言中。例如，在 C++ 中，泛型函数（在 C++ 术语中是函数模板）可以调用泛型类型值上的任何方法。也就是说，在 C++ 的实现中，调用 v.String() 是可以的。如果在没有 String 方法的类型参数上调用这个函数，则在使用该类型参数编译对 v.String 的调用时才会报告错误。这些错误可能很长，因为在错误发生之前可能有好几层泛型函数调用，必须报告所有这些函数调用才能了解错误的原因。

对于 Go 来说，使用 C++ 这种类型的实现会比较糟糕。其中一个原因是语言风格问题。在 Go 中，我们不会依赖于对名称的引用（如本例中的 String），并假设它们存在。Go 会在遇到所有的名称时将其解析为它们的声明。

另一个原因是 Go 是为大型编程项目设计的。我们必须考虑泛型函数的定义（上文的 `Stringify`）和对泛型函数的调用（没有给出，可能在其他包中）相距甚远的情况。一般来说，所有泛型代码都期望类型参数满足某些要求。我们将这些需求称为约束（其他语言也有类似的概念，称为类型界限、特征界限或概念）。在上文的例子中，约束非常明显：该类型必须有一个 `String() string` 方法。在其他例子中，约束的需求就不一定这么显而易见。

我们不希望依据 `Stringify` 可能的具体行为（在这个例子中指的是调用 `String` 方法）派生约束。如果这样做，`Stringify` 具体实现的一个小改变就可能会改变约束。这意味着不经意的一个小修改就会导致调用这个函数的代码意外崩溃。相反，特意更改 `Stringify` 的约束，并强制调用者更改，则是可以接受的。我们想要避免的是 `Stringify` 的约束被意料之外地改变。

这意味着约束必须对调用方传递的类型参数和泛型函数内的代码设置限制。调用方只能传递满足约束的类型参数。泛型函数只能以约束允许的方式使用这些值。泛型代码只能使用其类型参数已知会实现的操作，我们认为任何试图在 Go 中编程时定义泛型的场合都适用于这条铁律。

##### any 类型允许的操作

在我们进一步讨论约束之前，简单留意一下当约束为 `any` 会发生什么。如果一个泛型函数对类型参数使用 any 约束（如上面的 Print 方法），则该参数可以是任意类型。泛型函数对该类型的值可以使用的唯一操作是那些对任何类型的值都允许的操作。在上面的例子中，Print 函数声明了类型为类型参数 T 的一个变量 v，并将这个变量传递给一个函数。

any 类型允许的操作有：

- 声明这些类型的变量
- 为这些变量赋予同一类型的其他值
- 将这些变量传递给函数或从函数返回这些值
- 对这些变量取址
- 将这些类型的值转换或赋值给 `interface{}`类型
- 转换类型值 `T` 为类型 `T` (虽然没什么用，但是是允许的)
- 使用类型断言将一个接口类型的值转换为对应的类型
- 在类型判断的 `switch` 中用类型作为 `case`
- 定义和使用使用了这些类型的复合类型，例如该类型的切片
- 将类型传递给一些预声明的函数，如 `new`

虽然目前还没有相关的计划，但未来的语言更改有可能会添加其他类似的操作。

##### 定义约束

Go 已经有了一个大致上可以满足我们对约束的需求的结构：接口类型。接口类型是方法的集合。只有实现了一个接口内所有方法的类型的值，可以赋给对应的接口类型的变量。除了对任何类型都允许的那些操作之外，接口类型的值唯一可以进行的操作是调用方法。

使用类型参数调用泛型函数类似于为接口类型的变量赋值：类型参数必须实现类型参数的约束。编写泛型函数类似于使用接口类型的值：泛型代码只能使用约束所允许的操作（或 any 类型所允许的操作）。

因此在这种设计下，约束只是一种接口类型。满足约束意味着实现接口类型。（稍后我们将重申这一点，以便为方法调用以外的操作定义约束，例如二元运算符）。

对于 `Stringify` 那个例子而言，我们需要一个接口类型，其 `String` 方法没有入参，并返回 `String` 类型的值。

```go
// Stringer 是一种类型约束，它要求类型参数具有 String 方法，并允许泛型函数调用 String。
// String 方法应该返回其值对应的字符串表示形式。
type Stringer interface {
	String() string
}
```

（虽然与本文的讨论无关，但是这段代码定义了与标准库中 `fmt.Stringer` 类型相同的接口，实际的代码一般只会直接使用 `fmt.Stringer`。）

##### Any 约束

既然我们知道约束只是一种接口类型，那么我们就可以解释 `any` 作为约束的含义。如上所示，`any` 约束允许任何类型作为类型参数，并且只允许函数使用 `any` 类型所允许的操作。该接口的接口类型为空接口: `interface{}`。所以我们可以把 `Print` 例子写成

```go
// Print 可以打印任何切片中的元素。
// Print 具有参数类型 T， 并且只有一个（普通）参数s，该参数是 T 类型参数的切片。
func Print[T interface{}](s []T) {
	// 同上文
}
```

但是，如果每次编写`any`类型的泛型函数时都必须编写 `interface{}` ，是非常繁琐的。因此在这个设计中，我们建议 `any` 类型约束等效于 `interface{}` 。这是预声明的，在 universe 块中隐式声明。将 `any` 作为类型约束以外的任何东西使用都是无效的。

（注：当然，我们也可以使 `any` 在通常情况下也可用作  `interface{}`  的别名，或定义为 `interface{}` 的新定义类型。但是，我们不希望泛型的设计可能会导致对非泛型代码的重大更改。添加 `any` 作为 `interface{}` 的通用名称可以而且应该被单独讨论）。

##### 使用约束

对泛型函数而言，约束可以被认为是类型参数的类型：元类型。如上所示，约束作为类型参数的元类型出现在类型参数列表中。

```go
// Stringify 对 s 的每个元素调用 String 方法, 并返回结果
func Stringify[T Stringer](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
```

类型参数 `T` 之后是应用于 `T` 的约束，在本例中是 `Stringer`。

##### 多个类型参数

尽管 `Stringify` 示例只有一个类型参数，但函数可以有多个类型参数。

```go
// Print2 有两个类型参数和两个普通参数。
func Print2[T1, T2 any](s1 []T1, s2 []T2) { ... }
```

与下面的例子对比一下：

```go
// Print2Same 有一个类型参数和两个普通参数。
func Print2Same[T any](s1 []T, s2 []T) { ... }
```

在 Print2中，s1和 s2可以是不同类型的切片。在 Print2Same中， s1和 s2必须是相同元素类型的切片。
正如每个普通参数可能有自己的类型一样，每个类型参数也可能有自己的约束。

```go
// Stringer 是需要 String 方法的类型约束。
// String 方法应返回值的字符串表示形式。
type Stringer interface {
	String() string
}

// Plusser 是需要 Plus 方法的类型约束。
// Plus 方法需要将参数添加到内部字符串并返回结果。
type Plusser interface {
	Plus(string) string
}

// ConcatTo 分别从 String 方法和 Plus 方法各获得一个元素切片，
// 切片元素数量应当相同。
// 这会将 s 的每个元素转化为一个字符串，传递给 p 的相应元素的 Plus 方法，
// 然后用切片返回结果字符串。
func ConcatTo[S Stringer, P Plusser](s []S, p []P) []string {
	r := make([]string, len(s))
	for i, v := range s {
		r[i] = p[i].Plus(v.String())
	}
	return r
}
```

单个约束可用于多个类型参数，就像单个类型可用于多个普通参数一样。约束会被分别应用到每个类型参数上。

```go
// Stringify2 将两个不同类型的切片分别转换为字符串，并返回串联后的结果。
func Stringify2[T1, T2 Stringer](s1 []T1, s2 []T2) string {
	r := ""
	for _, v1 := range s1 {
		r += v1.String()
	}
	for _, v2 := range s2 {
		r += v2.String()
	}
	return r
}
```

##### 泛型类型

不仅是泛型函数，我们还想要泛型类型。我们建议将类型扩展为可接受类型参数。

```go
// 将 Vector 定义为 any 类型的切片的名称
type Vector[T any] []T
```

类型的类型参数就像函数的类型参数一样。
在类型定义中，类型参数可以像任何其他类型一样使用。
若要使用泛型类型，必须提供类型参数。这就是所谓的实例化。类型参数像往常一样出现在方括号中。当我们通过为类型参数提供类型声明来实例化类型时，我们生成了一个新的类型，其中类型定义中类型参数的每次使用都被相应的类型声明替换。

```go
// v 是 int 类型的 Vector
//
// 这类似于，假设"Vector[int]"是一个有效的标识符
// 然后写这样的代码：
//   type "Vector[int]" []int
//   var v "Vector[int]"
// Vector[int]的所有用法都将引用相同的"Vector[int]"类型。
//
var v Vector[int]
```

泛型类型可以有方法。方法的接收者类型必须声明与接收者类型定义中声明的相同数量的类型参数。它们的声明没有任何约束。

```go
// Push 在 Vector 的末尾添加一个值
func (v *Vector[T]) Push(x T) { *v = append(*v, x) }
```

方法声明中列出的类型参数不必与类型声明中的类型参数具有相同的名称。特别地，如果方法没有使用它们，它们可以是 _。
就好像类型一般都可以引用自己，泛型类型也可以引用自己，但是在这种情况下，类型参数必须是以相同顺序列出。这个限制可防止类型实例化的无限递归。

```go
// List 是一个类型为 T 的元素的链表
type List[T any] struct {
	next *List[T] // 这里对 List[T] 的引用是可以的
	val  T
}

// This type is INVALID.
type P[T1, T2 any] struct {
	F *P[T2, T1] // 无效; 应该是 [T1, T2]
}
```

这一限制同时适用于直接和间接引用。

```
// ListHead 是链表的头部。
type ListHead[T any] struct {
	head *ListElement[T]
}

// ListElement 是一个拥有头部的链表中的一个元素
// 每个元素都有一个指针指回头部
type ListElement[T any] struct {
	next *ListElement[T]
	val  T
	// 这里使用 ListHead[T] 是可以的。
	// ListHead[T] 引用 ListElement[T]， ListElement[T] 又引用了 ListHead[T].
	// 使用 ListHead[int] 则不行, 因为 ListHead[T] 间接引用了 ListHead[int]。
	head *ListHead[T]
}
```

（注：等我们考察了足够多人们对如何编写泛型代码的期望后，也许可以放宽这一规则，允许在某些情况下使用不同的类型参数。）

泛型类型的类型参数也可以具有 `Any` 以外的约束。

```go
// StringableVector 是一种切片, 其元素必须拥有 Stringer 方法。
type StringableVector[T Stringer] []T

func (s StringableVector[T]) String() string {
	var sb strings.Builder
	for i, v := range s {
		if i > 0 {
			sb.WriteString(", ")
		}
		// 这里调用 v.String 是可以的，因为 v 的类型为 T
		// 而 T 的约束类型为 Stringer。
		sb.WriteString(v.String())
	}
	return sb.String()
}
```

##### 方法不应该接受额外的类型参数

尽管泛型类型的方法可以使用该类型的参数，但方法本身可能没有其他类型参数。如果向方法中添加类型参数是有用的，那么人们就应该编写一个适当的参数化顶级函数。

在问题章节有更多关于这方面的讨论。

##### 运算符

正如我们已经看到的，我们使用接口类型作为约束。接口类型只提供一组方法，没有其他内容。这意味着到目前为止，泛型函数只能对类型参数的值(任何类型都允许的操作除外)执行调用方法。
但是，方法调用不足以满足我们想要表达的所有内容。思考下面这个简单的函数，它返回一个切片中的最小元素，该切片被假定为非空的。

```go
// 这个函数是 *无效* 的.
func Smallest[T any](s []T) T {
	r := s[0] // 如果切片为空会触发 panic
	for _, v := range s[1:] {
		if v < r { // 无效
			r = v
		}
	}
	return r
}
```

任何合理的泛型实现都应该允许您编写这个函数。问题在于表达式 `v < r`。这里假设 `T` 支持 `<` 运算符，但是 `T` 的约束是 `any`。对于 `any` 约束，`Smallest` 函数只能使用所有类型都可用的操作，但不是所有 Go 类型都支持 `<` 。遗憾的是，由于 `<` 不是方法，因此目前没什么好办法来编写允许 `<` 的约束（接口类型）。

